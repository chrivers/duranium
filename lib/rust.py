from transwarp.template import context

##### header #####

def header():
    return \
        "// ------------------------------------------\n" \
        "// Generated by Transwarp\n" \
        "//\n" \
        "// THIS FILE IS AUTOMATICALLY GENERATED.\n" \
        "// DO NOT EDIT. ALL CHANGES WILL BE LOST.\n" \
        "// ------------------------------------------"

##### type handling #####

def is_ref_type(typ):
    return typ.name in ("string", "struct", "sizedarray", "ascii_string", "array", "map", "option", "bitflags")

primitive_map = {
    "u8": "u8",
    "u16": "u16",
    "u32": "u32",
    "u64": "u64",

    "i8": "i8",
    "i16": "i16",
    "i32": "i32",

    "f32": "f32",
}

declare_map = {
    "bool8": "bool",
    "bool16": "bool",
    "bool32": "bool",
    "string": "String",
    "ascii_string": "String",
}

convert_map = {
    "bool8": "bool8",
    "bool16": "bool16",
    "bool32": "bool32",
    "string": "string",
    "ascii_string": "ascii_string",
}

def declare_struct_type(tp):
    if not tp:
        raise ValueError("Empty type")
    elif tp.name in declare_map:
        return declare_map[tp.name]
    elif tp.name in primitive_map:
        return primitive_map[tp.name]
    elif tp.name == "sizedarray":
        return "[%s; %d]" % (declare_struct_type(tp[0]), int(tp[1].name))
    elif tp.name == "array":
        return "Vec<%s>" % declare_struct_type(tp[0])
    elif tp.name == "struct":
        return tp[0].name
    elif tp.name == "enum":
        return tp[1].name
    elif tp.name == "map":
        return "HashMap<%s, %s>" % (tp[0].name, declare_struct_type(tp[1]))
    elif tp.name == "option":
        return "Option<%s>" % declare_struct_type(tp[0])
    elif tp.name == "bitflags":
        return tp[1].name
    else:
        raise TypeError("No type mapping defined for [%s]" % tp.name)

def declare_update_type(tp):
    if tp.name == "sizedarray":
        return "[%s; %d]" % (declare_update_type(tp[0]), int(tp[1].name))
    else:
        return "Option<%s>" % declare_struct_type(tp)

def reader_function(tp):
    if tp.name in primitive_map:
        return "read_%s" % primitive_map[tp.name]
    elif tp.name in convert_map:
        return "read_%s" % convert_map[tp.name]
    elif tp.name in ("bitflags", "struct", "map", "option"):
        return "read"
    elif tp.name == "enum" and tp[0].name == "u8":
        return "read_enum8"
    elif tp.name == "enum" and tp[0].name == "u32":
        return "read_enum32"
    else:
        raise TypeError("No reader function for [%r]" % tp)

def writer_function(tp):
    if tp.name in primitive_map:
        return "write_%s" % primitive_map[tp.name]
    elif tp.name in convert_map:
        return "write_%s" % convert_map[tp.name]
    elif tp.name in ("bitflags", "struct", "map", "option"):
        return "write"
    elif tp.name == "enum" and tp[0].name == "u8":
        return "write_enum8"
    elif tp.name == "enum" and tp[0].name == "u32":
        return "write_enum32"
    else:
        raise TypeError("No writer function for [%r]" % tp)

##### struct fields #####

def read_struct_field(type):
    if type.name == "array":
        if type[1]:
            if len(type[1].name) <= 4:
                return "rdr.read_array_u8(%s)?" % (type[1].name)
            else:
                return "rdr.read_array_u32(%s)?" % (type[1].name)
        else:
            return "rdr.read_array()?"
    elif type.name == "sizedarray":
        return "[ %s ]" % (", ".join([(read_struct_field(type[0]))] * int(type[1].name)))
    else:
        return "rdr.%s()?" % reader_function(type)

def write_struct_field(fieldname, type):
    if (type.name == "sizedarray" and type[0].name != "bool8") or (type.name == "array" and len(type._args) == 1):
        return "wtr.write_array(%s)?" % fieldname
    if type.name == "sizedarray":
        return "for elm in %s { %s }" % (fieldname, write_struct_field("*elm", type[0]))
    elif type.name == "string":
        return "wtr.%s(&%s)?" % (writer_function(type), fieldname)
    elif type.name == "array" and len(type._args) == 2:
        if len(type[1].name) <= 4:
            return "wtr.write_array_u8(%s, %s)?" % (fieldname, type[1].name)
        else:
            return "wtr.write_array_u32(%s, %s)?" % (fieldname, type[1].name)
    else:
        return "wtr.%s(%s)?" % (writer_function(type), fieldname)

##### updates fields #####

def read_update_field(rdr, mask, object, field, type):
    if type.name == "sizedarray":
        rep = int(type[1].name)
        return "[ %s ]" % ", ".join([read_update_field(rdr, mask, object, field, type[0])] * rep)
    else:
        return "parse_bitmask_field!(%s, %s.%s()?)" % (mask, rdr, reader_function(type))

def write_update_field(wtr, mask, fieldname, type):
    if type.name == "sizedarray":
        return "for _elem in %s.iter() { %s }" % (fieldname, write_update_field(wtr, mask, "*_elem", type[0]))
    else:
        if is_ref_type(type):
            fieldname = "%s.as_ref()" % fieldname
        return "write_bitmask_field!(%s, %s, %s, %s)" % (fieldname, wtr, mask, writer_function(type))

##### diff fields #####

def diff_update_field(fieldname, fieldtype):
    if fieldtype and fieldtype.name == "sizedarray":
        return "[ %s ]" % ",\n".join(["{ %s }" % diff_update_field("%s[%s]" % (fieldname, x), None) for x in range(int(fieldtype[1].name))])
    elif fieldtype and fieldtype.name == "string":
        return "if self.%s == other.%s { Some(other.%s.to_owned()) } else { None }" % (fieldname, fieldname, fieldname)
    else:
        return "diff_field!(self.%s, other.%s)" % (fieldname, fieldname)

##### apply fields #####

def apply_update_field(fieldname, fieldtype):
    if fieldtype and fieldtype.name == "sizedarray":
        return "%s" % "; ".join(["{ %s }" % apply_update_field("%s[%s]" % (fieldname, x), None) for x in range(int(fieldtype[1].name))])
    elif fieldtype and fieldtype.name == "string":
        return "if let Some(ref val) = update.%s { self.%s = val.to_owned(); }" % (fieldname, fieldname)
    else:
        return "if let Some(val) = update.%s { self.%s = val; }" % (fieldname, fieldname)

##### produce fields #####

def produce_update_field(fieldname, fieldtype):
    if fieldtype and fieldtype.name == "sizedarray":
        return "[ %s ]" % ", ".join(["{ %s }" % produce_update_field("%s[%s]" % (fieldname, x), None) for x in range(int(fieldtype[1].name))])
    elif fieldtype and fieldtype.name == "string":
        return "match update.%s { Some(ref s) => s.clone(), None => self.%s.clone() }" % (fieldname, fieldname)
    else:
        return "update.%s.unwrap_or(self.%s)" % (fieldname, fieldname)

##### field refs #####

def ref_struct_field(fld):
    if is_ref_type(fld.type):
        return "ref %s" % fld.name
    else:
        return fld.name

##### packets #####

def get_packet(name):
    packets = context["packets"]
    if "::" in name:
        packetname, casename = name.split("::",1)
        return packets.get(packetname).fields.get(casename)
    else:
        return packets.get(name)

def get_parser(name):
    return context["parsers"].get(name)

def get_packet_padding(packet, name):
    if name == "valueInt":
        return 1 - len(packet.fields)
    elif name == "valueFourInts":
        return 4 - len(packet.fields)
    else:
        return 0

def generate_packet_ids(parsername):
    res = {}
    for field in get_parser(parsername).fields:
        if field.type.name == "struct":
            res[field.type[0].name] = (field.type, field.name, None, None)
        elif field.type.name == "parser":
            prs = get_parser(field.type[0].name)
            for fld in prs.fields:
                res[fld.type[0].name] = (fld.type, field.name, fld.name, prs.arg)
    return res
